<!DOCTYPE HTML>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>研究内容 | Takuya Matsumoto / 松本 卓也</title>
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js"></script>
<![endif]-->
<link href="../css/style.css" rel="stylesheet" media="all">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

<div id="container">
  <header id="header">
    <h1>Takuya Matsumoto / 松本 卓也</h1>
  </header>

  <div id="nav_frame">
    <nav>
      <ul id="nav1">
        <li><a href="../index.html">ホーム</a></li>
        <li><a href="../research.html">研究内容</a></li>
        <li><a href="../cv.html">経歴</a></li>
        <li><a href="../publications.html">研究業績</a></li>
        <li><a href="../access.html">連絡先</a></li>
        <li><a href="../review.html">書評</a></li>
        <li><a href="../blog.html">Blog</a></li>
        <li><a href="../index-e.html">ENGLISH</a></li>
      </ul>
    </nav>
  </div>

  <div id="main">
    <h1>イジング模型シミュレーター</h1>
    <h2>イジング模型とは？</h2>
        <p>
            イジング模型は、物理学における統計力学のモデルで、スピン系の相転移を研究するために広く用いられています。スピンは、磁性体の原子や分子が持つ磁気モーメントを表し、通常は上向き（+1）または下向き（-1）の二つの状態を取ります。イジング模型では、隣接するスピン同士の相互作用を考慮し、全体のエネルギーを最小化するようにスピンの配置が変化します。特に、温度が低いとスピンは整列しやすく、磁性体が強い磁気を示すことが知られています。一方、温度が高いとスピンの配置はランダムになり、磁性体の磁気は弱くなります。
        </p>
        <p>
            このシミュレーターでは、2次元イジング模型を用いて、スピンの配置や磁化の変化を可視化します。温度や相互作用の強さを調整することで、スピン系の挙動を観察できます。特に、相転移の様子やスピンの整列状態をリアルタイムで確認することができます。
        </p>
        <p>
            とりあえずシミュレーターを動かしてみましょう！
        </p> 
    
    <h2>イジング模型シミュレーター</h2>
    <!-- ↓ ここからイジングシミュレーター本体 ↓ -->
    <div id="ising-simulator">

      <div class="control-panel">
        <div class="input-row"><label>温度 T (/k<sub>B</sub>J):</label> <input type="number" id="temperature" value="0.8" step="0.1"></div>
        <div class="input-row"><label>相互作用 J:</label> <input type="number" id="interaction" value="1.0" step="0.1"></div>
        <div class="input-row"><label>格子サイズ N:</label> <input type="number" id="latticeSize" value="20" step="10"></div>
        <div class="input-row"><label>熱化ステップ数:</label> <input type="number" id="thermalSteps" value="0" step="10"></div>
        <div class="input-row"><label>更新ステップ間隔:</label> <input type="number" id="updateInterval" value="10" step="1"></div>
        <div class="input-row"><label>描画時間(ms/step):</label> <input type="number" id="stepSpeed" value="1" step="10"></div>

        <button onclick="startSimulation()">シミュレーション開始</button>
        <div style="height: 10px;"></div>
        <button onclick="stopSimulation()">停止</button>
      </div>

      <div class="plot-area">
        <div>
          <h3>スピン配置</h3>
          <canvas id="isingCanvas" width="400" height="400"></canvas>
        </div>
        <div>
          <h3>スピン期待値の履歴</h3>
          <canvas id="magChart" width="380" height="380" style="border:none;"></canvas>
        </div>
      </div>

    </div>
    <!-- ↑ ここまでイジングシミュレーター本体 ↑ -->
    <h2>使い方</h2>
    <ol>
      <li>温度 T、相互作用 J、格子サイズ N などのパラメータを設定します。(格子サイズは大きすぎると計算が重くなります。)</li>
      <li>「シミュレーション開始」ボタンをクリックして、シミュレーションを開始します。（初期条件によっては相転移温度以下でもドメインができることがあるので何回か回してみてください。）</li>
      <li>スピン配置やスピン期待値の履歴がリアルタイムで表示されます。</li>
      <li>「停止」ボタンをクリックして、シミュレーションを停止します。</li>
    </ol>

    <h2>シミュレーターがしていること</h2>
    <p>
      工事中
    </p>
  </div>

</div>

<script>
let spins = [], J = 1.0, T = 0.8, thermalSteps = 0, stepSpeed = 1, updateInterval = 10;
let currentStep = 0, running = false, magChart = null, N = 20;
let canvas, ctx;

function initSpins() {
  spins = [];
  for (let i = 0; i < N; i++) {
    spins[i] = [];
    for (let j = 0; j < N; j++) {
      spins[i][j] = Math.random() < 0.5 ? 1 : -1;
    }
  }
}

function drawSpins() {
  let cellSize = canvas.width / N;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      ctx.fillStyle = spins[i][j] === 1 ? 'red' : 'blue';
      ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
    }
  }
}

function metropolisStep() {
  for (let step = 0; step < (N * N); step++) {
    let i = Math.floor(Math.random() * N);
    let j = Math.floor(Math.random() * N);
    let s = spins[i][j];
    let nb = spins[(i+1)%N][j] + spins[(i-1+N)%N][j] + spins[i][(j+1)%N] + spins[i][(j-1+N)%N];
    let dE = (-1) * 2 * (-1) * J * s * nb;
    if (dE <= 0) {
      spins[i][j] *= -1;
    }
    else if (Math.random() < Math.exp(-dE / T)) {
      spins[i][j] *= -1;
    }
  }
}

function computeMagnetization() {
  let m = 0;
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      m += spins[i][j];
    }
  }
  return m / (N * N);
}

function initializeMagnetizationChart() {
  const ctxChart = document.getElementById('magChart').getContext('2d');
  if (magChart) magChart.destroy();

  magChart = new Chart(ctxChart, {
    type: 'line',
    data: {
      datasets: [{
        label: 'スピン期待値',
        data: [],
        borderColor: 'red',
        borderWidth: 4,
        pointRadius: 0,
        fill: false,
        tension: 0
      }]
    },
    options: {
      responsive: false,
      animation: false,
      plugins: { legend: { display: false } },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'ステップ数', color: 'black', font: { size: 18 } },
          ticks: {
            color: 'black',
            font: { size: 16 },
            callback: (value, index, ticks) => {
              const min = ticks[0].value;
              const max = ticks[ticks.length - 1].value;
              return (value === min || value === max) ? value : '';
            },
            maxRotation: 0, minRotation: 0
          },
          grid: { color: '#cccccc', tickLength: 5 }
        },
        y: {
          type: 'linear',
          min: -1, max: 1,
          title: { display: true, text: 'スピン期待値', color: 'black', font: { size: 18 } },
          ticks: { color: 'black', font: { size: 16 }, stepSize: 0.5 },
          grid: { color: '#cccccc', tickLength: 5 }
        }
      },
      layout: { padding: 10 }
    }
  });
}

function startSimulation() {
  T = parseFloat(document.getElementById('temperature').value);
  J = parseFloat(document.getElementById('interaction').value);
  N = parseInt(document.getElementById('latticeSize').value);
  thermalSteps = parseInt(document.getElementById('thermalSteps').value);
  updateInterval = parseInt(document.getElementById('updateInterval').value);
  stepSpeed = parseInt(document.getElementById('stepSpeed').value);
  canvas = document.getElementById('isingCanvas');
  ctx = canvas.getContext('2d');
  initSpins();
  currentStep = 0;
  initializeMagnetizationChart();
  running = true;
  requestAnimationFrame(simulate);
}

function stopSimulation() {
  running = false;
}

function simulate() {
  if (!running) return;
  metropolisStep();
  currentStep++;

  if (currentStep % updateInterval === 0) {
    drawSpins();
    if (currentStep > thermalSteps) {
      const plotIndex = currentStep - thermalSteps;
      const m = computeMagnetization();
      magChart.data.datasets[0].data.push({x: plotIndex, y: m});
      magChart.options.scales.x.min = 0;
      magChart.options.scales.x.max = plotIndex;
      magChart.update();
    }
  }
  setTimeout(() => requestAnimationFrame(simulate), stepSpeed);
}
</script>

</body>
</html>